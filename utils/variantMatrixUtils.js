/**
 * Variant Matrix Utilities
 *
 * Generates all possible variant combinations (cartesian product) from
 * a category's attributeSchema. Existing variant data is preserved
 * when a matching attributeKey already exists.
 */

/**
 * Compute the canonical attributeKey for a combination.
 * Attributes are sorted alphabetically so key order is deterministic.
 *
 * @param {Array<{name:string, value:string}>} attributes
 * @returns {string}  e.g. "Color:Red|Size:L"
 */
function buildAttributeKey(attributes) {
  if (!Array.isArray(attributes) || attributes.length === 0) return "";
  return attributes
    .slice()
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((a) => `${a.name}:${a.value}`)
    .join("|");
}

/**
 * Compute the cartesian product of an array of arrays.
 *
 * @param {Array<Array<*>>} arrays
 * @returns {Array<Array<*>>}
 */
function cartesianProduct(arrays) {
  if (arrays.length === 0) return [[]];
  const [first, ...rest] = arrays;
  const restProduct = cartesianProduct(rest);
  return first.flatMap((item) => restProduct.map((combo) => [item, ...combo]));
}

/**
 * Generate the full variant matrix for a product.
 *
 * How it works:
 *  1. For each attribute in the category's attributeSchema that has at least
 *     one option, collect its options.
 *  2. Compute the cartesian product of all option arrays.
 *  3. For each resulting combination:
 *     - Build the attributeKey.
 *     - If an existing variant already has that key, PRESERVE its price/stock/images.
 *     - Otherwise create a skeleton variant (price=0, stock=0, isActive=false)
 *       so the admin can fill it in before publishing.
 *
 * @param {Array<{name:string, options:string[], isRequired:boolean}>} attributeSchema
 *   The category's attributeSchema (only entries with options are used).
 * @param {Array<Object>} existingVariants
 *   The product's current variants array (may be empty).
 * @returns {{variants: Array<Object>, combinationCount: number, isPreview: boolean}}
 */
function generateVariantMatrix(attributeSchema = [], existingVariants = []) {
  // Filter to attribute axes that actually have selectable options
  const activeAxes = attributeSchema.filter(
    (attr) => Array.isArray(attr.options) && attr.options.length > 0
  );

  if (activeAxes.length === 0) {
    return {
      variants: existingVariants,
      combinationCount: 0,
      isPreview: true,
      message:
        "No attribute options defined. Add options to the category attribute schema first.",
    };
  }

  // Build array-of-arrays: [ ["Red","Blue"], ["S","M","L"] ]
  const optionArrays = activeAxes.map((attr) =>
    attr.options.map((opt) => ({ name: attr.name, value: opt }))
  );

  // Cartesian product → [ [{name:"Color",value:"Red"},{name:"Size",value:"S"}], ... ]
  const combinations = cartesianProduct(optionArrays);

  // Build lookup map from existing variants for O(1) merge
  const existingByKey = new Map();
  for (const v of existingVariants) {
    const key =
      v.attributeKey || buildAttributeKey(v.attributes || []);
    existingByKey.set(key, v);
  }

  const mergedVariants = combinations.map((attrCombo) => {
    const attributes = attrCombo; // [{name, value}, ...]
    const attributeKey = buildAttributeKey(attributes);

    const existing = existingByKey.get(attributeKey);

    if (existing) {
      // Preserve all existing data — only refresh attributes + key
      return {
        ...existing,
        attributes,
        attributeKey,
      };
    }

    // New combination — create skeleton (admin must fill price/stock)
    return {
      variantId: null,       // generated by controller on save
      sku: null,             // generated by controller on save
      attributes,
      attributeKey,
      price: 0,
      salePrice: null,
      stock: 0,
      images: [],
      isActive: false,       // inactive until admin confirms price/stock
      _isNew: true,          // flag for the frontend to highlight new rows
    };
  });

  return {
    variants: mergedVariants,
    combinationCount: mergedVariants.length,
    newCombinations: mergedVariants.filter((v) => v._isNew).length,
    preservedCombinations: mergedVariants.filter((v) => !v._isNew).length,
    isPreview: true, // caller must POST back to confirm save
  };
}

module.exports = { generateVariantMatrix, buildAttributeKey, cartesianProduct };
