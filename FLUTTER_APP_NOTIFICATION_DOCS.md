# Flutter App Notification System Integration Guide

## Table of Contents
1. [Overview](#overview)
2. [Setup Requirements](#setup-requirements)
3. [Firebase Cloud Messaging Setup](#firebase-cloud-messaging-setup)
4. [API Integration](#api-integration)
5. [Notification Features](#notification-features)
6. [API Endpoints](#api-endpoints)
7. [Data Models](#data-models)
8. [Implementation Guide](#implementation-guide)
9. [UI/UX Guidelines](#uiux-guidelines)
10. [Testing](#testing)
11. [Troubleshooting](#troubleshooting)

---

## Overview

The notification system provides two types of notifications:
1. **Admin Posts**: Offers, announcements, product shares (with likes & comments)
2. **System Notifications**: Order updates, payment alerts, wallet transactions

Users can:
- View notification feed with pagination
- Like and comment on admin posts
- Mark notifications as read
- Manage notification preferences
- Receive push notifications via Firebase Cloud Messaging (FCM)

**Base URL**: `https://your-api-domain.com/api/notifications`

---

## Setup Requirements

### Flutter Dependencies

Add these to your `pubspec.yaml`:

```yaml
dependencies:
  firebase_core: ^2.24.2
  firebase_messaging: ^14.7.9
  flutter_local_notifications: ^16.3.0
  http: ^1.1.0
  shared_preferences: ^2.2.2
  provider: ^6.1.1  # or your state management solution
```

### Permissions

#### Android (`android/app/src/main/AndroidManifest.xml`)

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Permissions -->
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
    <uses-permission android:name="android.permission.VIBRATE"/>

    <application>
        <!-- Notification Icon -->
        <meta-data
            android:name="com.google.firebase.messaging.default_notification_icon"
            android:resource="@drawable/ic_notification" />

        <!-- Notification Color -->
        <meta-data
            android:name="com.google.firebase.messaging.default_notification_color"
            android:resource="@color/notification_color" />

        <!-- Notification Channel -->
        <meta-data
            android:name="com.google.firebase.messaging.default_notification_channel_id"
            android:value="default" />
    </application>
</manifest>
```

#### iOS (`ios/Runner/Info.plist`)

```xml
<key>UIBackgroundModes</key>
<array>
    <string>fetch</string>
    <string>remote-notification</string>
</array>
```

---

## Firebase Cloud Messaging Setup

### 1. Firebase Project Setup

1. Go to [Firebase Console](https://console.firebase.google.com/)
2. Create or select your project
3. Add Android and iOS apps
4. Download configuration files:
   - `google-services.json` for Android â†’ `android/app/`
   - `GoogleService-Info.plist` for iOS â†’ `ios/Runner/`

### 2. Initialize Firebase in Flutter

```dart
// main.dart
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'firebase_options.dart'; // Generated by FlutterFire CLI

// Background message handler (must be top-level function)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp();
  print('Background message: ${message.messageId}');
  // Handle background notification
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Set background message handler
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  runApp(MyApp());
}
```

### 3. Request Notification Permissions

```dart
import 'package:firebase_messaging/firebase_messaging.dart';

class NotificationService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;

  Future<void> requestPermission() async {
    NotificationSettings settings = await _messaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
      provisional: false,
    );

    if (settings.authorizationStatus == AuthorizationStatus.authorized) {
      print('User granted permission');
    } else if (settings.authorizationStatus == AuthorizationStatus.provisional) {
      print('User granted provisional permission');
    } else {
      print('User declined or has not accepted permission');
    }
  }
}
```

### 4. Get FCM Token

```dart
Future<String?> getFCMToken() async {
  try {
    String? token = await _messaging.getToken();
    print('FCM Token: $token');
    return token;
  } catch (e) {
    print('Error getting FCM token: $e');
    return null;
  }
}

// Listen for token refresh
void listenToTokenRefresh() {
  _messaging.onTokenRefresh.listen((newToken) {
    print('FCM Token refreshed: $newToken');
    // Send new token to backend
    registerFCMToken(newToken);
  });
}
```

---

## API Integration

### Authentication

All API requests require authentication. Include JWT or Firebase token in headers:

```dart
Map<String, String> getAuthHeaders(String token) {
  return {
    'Authorization': 'Bearer $token',
    'Content-Type': 'application/json',
  };
}
```

The backend supports both JWT and Firebase ID tokens.

---

## Notification Features

### 1. Notification Feed
- Paginated list of notifications
- Shows admin posts and system notifications
- Pull-to-refresh support
- Infinite scroll

### 2. Notification Details
- Full notification content
- Image display (if available)
- Like/unlike functionality
- Comment section with pagination
- Share options (for product shares)

### 3. Engagement
- Like admin posts (toggle like/unlike)
- Add comments
- Delete own comments
- View like and comment counts

### 4. Push Notifications
- Receive real-time notifications
- Handle foreground, background, and terminated states
- Deep linking to notification details

### 5. Preferences
- Enable/disable push notifications
- Customize notification types (orders, payments, offers)

---

## API Endpoints

### 1. Get Notification Feed

**Endpoint**: `GET /api/notifications`

**Headers**:
```dart
{
  'Authorization': 'Bearer <token>',
  'Content-Type': 'application/json'
}
```

**Query Parameters**:
```dart
{
  'page': '1',          // Page number (default: 1)
  'limit': '20',        // Items per page (default: 20, max: 100)
  'type': 'ADMIN_POST'  // Optional: Filter by type (ADMIN_POST, SYSTEM_NOTIFICATION)
}
```

**Dart Implementation**:
```dart
import 'package:http/http.dart' as http;
import 'dart:convert';

Future<Map<String, dynamic>> getNotificationFeed({
  required String token,
  int page = 1,
  int limit = 20,
  String? type,
}) async {
  final queryParams = {
    'page': page.toString(),
    'limit': limit.toString(),
    if (type != null) 'type': type,
  };

  final uri = Uri.parse('$baseUrl/api/notifications')
      .replace(queryParameters: queryParams);

  final response = await http.get(
    uri,
    headers: getAuthHeaders(token),
  );

  if (response.statusCode == 200) {
    return json.decode(response.body);
  } else {
    throw Exception('Failed to load notifications');
  }
}
```

**Response**:
```json
{
  "success": true,
  "data": {
    "notifications": [
      {
        "_id": "notification_id",
        "notificationId": "NOTIF-1234567890",
        "type": "ADMIN_POST",
        "postType": "OFFER",
        "title": "50% Off on All Products!",
        "body": "Limited time offer! Get 50% discount on all products.",
        "imageUrl": "https://s3.amazonaws.com/bucket/image.jpg",
        "likeCount": 125,
        "commentCount": 45,
        "viewCount": 1250,
        "isLiked": false,
        "commentsEnabled": true,
        "likesEnabled": true,
        "publishedAt": "2025-11-22T10:00:00.000Z",
        "createdBy": {
          "name": "Admin",
          "profilePicture": "https://..."
        }
      },
      {
        "_id": "notification_id_2",
        "type": "SYSTEM_NOTIFICATION",
        "systemType": "ORDER_SHIPPED",
        "title": "Your Order is Shipped!",
        "body": "Your order #12345 is on the way.",
        "publishedAt": "2025-11-22T09:30:00.000Z",
        "metadata": {
          "orderId": "order_id",
          "trackingNumber": "TRACK123"
        }
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 150,
      "totalPages": 8,
      "hasMore": true
    }
  }
}
```

---

### 2. Get Single Notification

**Endpoint**: `GET /api/notifications/:id`

**Dart Implementation**:
```dart
Future<Map<String, dynamic>> getNotificationById({
  required String token,
  required String notificationId,
}) async {
  final uri = Uri.parse('$baseUrl/api/notifications/$notificationId');

  final response = await http.get(
    uri,
    headers: getAuthHeaders(token),
  );

  if (response.statusCode == 200) {
    return json.decode(response.body);
  } else {
    throw Exception('Failed to load notification');
  }
}
```

**Response**:
```json
{
  "success": true,
  "data": {
    "notification": {
      "_id": "notification_id",
      "title": "50% Off on All Products!",
      "body": "Limited time offer...",
      "imageUrl": "https://...",
      "likeCount": 125,
      "commentCount": 45,
      "isLiked": false,
      "commentsEnabled": true,
      "likesEnabled": true
    },
    "comments": [
      {
        "_id": "comment_id",
        "commentId": "CMT-123",
        "text": "Great offer!",
        "userName": "John Doe",
        "userAvatar": "https://...",
        "createdAt": "2025-11-22T10:15:00.000Z",
        "isMyComment": false
      }
    ],
    "commentsCount": 45,
    "hasMoreComments": true
  }
}
```

---

### 3. Get Unread Count

**Endpoint**: `GET /api/notifications/unread-count`

**Dart Implementation**:
```dart
Future<int> getUnreadCount({required String token}) async {
  final uri = Uri.parse('$baseUrl/api/notifications/unread-count');

  final response = await http.get(
    uri,
    headers: getAuthHeaders(token),
  );

  if (response.statusCode == 200) {
    final data = json.decode(response.body);
    return data['data']['unreadCount'];
  } else {
    throw Exception('Failed to get unread count');
  }
}
```

**Response**:
```json
{
  "success": true,
  "data": {
    "unreadCount": 15,
    "systemNotifications": 5,
    "adminPosts": 10
  }
}
```

**Usage**: Display badge on notification icon in app bar

---

### 4. Register FCM Token

**Endpoint**: `POST /api/notifications/register-token`

**Dart Implementation**:
```dart
Future<void> registerFCMToken({
  required String token,
  required String fcmToken,
}) async {
  final uri = Uri.parse('$baseUrl/api/notifications/register-token');

  final response = await http.post(
    uri,
    headers: getAuthHeaders(token),
    body: json.encode({
      'fcmToken': fcmToken,
    }),
  );

  if (response.statusCode != 200) {
    throw Exception('Failed to register FCM token');
  }
}
```

**Call this**:
- On app login
- When FCM token is refreshed
- After user enables push notifications in settings

---

### 5. Remove FCM Token

**Endpoint**: `POST /api/notifications/remove-token`

**Dart Implementation**:
```dart
Future<void> removeFCMToken({required String token}) async {
  final uri = Uri.parse('$baseUrl/api/notifications/remove-token');

  final response = await http.post(
    uri,
    headers: getAuthHeaders(token),
  );

  if (response.statusCode != 200) {
    throw Exception('Failed to remove FCM token');
  }
}
```

**Call this**:
- On user logout
- When user disables push notifications

---

### 6. Like/Unlike Notification

**Endpoint**: `POST /api/notifications/:id/like`

**Dart Implementation**:
```dart
Future<Map<String, dynamic>> toggleLike({
  required String token,
  required String notificationId,
}) async {
  final uri = Uri.parse('$baseUrl/api/notifications/$notificationId/like');

  final response = await http.post(
    uri,
    headers: getAuthHeaders(token),
  );

  if (response.statusCode == 200) {
    return json.decode(response.body);
  } else {
    throw Exception('Failed to toggle like');
  }
}
```

**Response**:
```json
{
  "success": true,
  "message": "Post liked successfully",
  "data": {
    "isLiked": true,
    "newLikeCount": 126
  }
}
```

**Rate Limit**: 100 likes per hour

---

### 7. Mark Notification as Read

**Endpoint**: `POST /api/notifications/:id/mark-read`

**Dart Implementation**:
```dart
Future<void> markAsRead({
  required String token,
  required String notificationId,
}) async {
  final uri = Uri.parse('$baseUrl/api/notifications/$notificationId/mark-read');

  final response = await http.post(
    uri,
    headers: getAuthHeaders(token),
  );

  if (response.statusCode != 200) {
    throw Exception('Failed to mark as read');
  }
}
```

**Call this**:
- When user opens notification detail
- When notification is viewed in feed (optional)

---

### 8. Add Comment

**Endpoint**: `POST /api/notifications/:id/comments`

**Dart Implementation**:
```dart
Future<Map<String, dynamic>> addComment({
  required String token,
  required String notificationId,
  required String text,
}) async {
  final uri = Uri.parse('$baseUrl/api/notifications/$notificationId/comments');

  final response = await http.post(
    uri,
    headers: getAuthHeaders(token),
    body: json.encode({
      'text': text,
    }),
  );

  if (response.statusCode == 201) {
    return json.decode(response.body);
  } else {
    throw Exception('Failed to add comment');
  }
}
```

**Validation**:
- Text length: 1-1000 characters
- URLs not allowed in comments
- Special characters are sanitized

**Response**:
```json
{
  "success": true,
  "message": "Comment added successfully",
  "data": {
    "comment": {
      "_id": "comment_id",
      "commentId": "CMT-123",
      "text": "Great offer!",
      "userName": "John Doe",
      "userAvatar": "https://...",
      "createdAt": "2025-11-22T10:15:00.000Z",
      "isMyComment": true
    },
    "newCommentCount": 46
  }
}
```

**Rate Limit**: 50 comments per hour

---

### 9. Get Comments

**Endpoint**: `GET /api/notifications/:id/comments`

**Query Parameters**:
```dart
{
  'page': '1',
  'limit': '20'
}
```

**Dart Implementation**:
```dart
Future<Map<String, dynamic>> getComments({
  required String token,
  required String notificationId,
  int page = 1,
  int limit = 20,
}) async {
  final queryParams = {
    'page': page.toString(),
    'limit': limit.toString(),
  };

  final uri = Uri.parse('$baseUrl/api/notifications/$notificationId/comments')
      .replace(queryParameters: queryParams);

  final response = await http.get(
    uri,
    headers: getAuthHeaders(token),
  );

  if (response.statusCode == 200) {
    return json.decode(response.body);
  } else {
    throw Exception('Failed to load comments');
  }
}
```

---

### 10. Delete Comment

**Endpoint**: `DELETE /api/notifications/:notificationId/comments/:commentId`

**Dart Implementation**:
```dart
Future<void> deleteComment({
  required String token,
  required String notificationId,
  required String commentId,
}) async {
  final uri = Uri.parse(
    '$baseUrl/api/notifications/$notificationId/comments/$commentId'
  );

  final response = await http.delete(
    uri,
    headers: getAuthHeaders(token),
  );

  if (response.statusCode != 200) {
    throw Exception('Failed to delete comment');
  }
}
```

**Note**: Users can only delete their own comments

---

### 11. Update Notification Preferences

**Endpoint**: `PUT /api/notifications/preferences`

**Dart Implementation**:
```dart
Future<void> updatePreferences({
  required String token,
  bool? pushEnabled,
  bool? orderUpdates,
  bool? promotionalOffers,
  bool? paymentAlerts,
  bool? systemNotifications,
}) async {
  final uri = Uri.parse('$baseUrl/api/notifications/preferences');

  final body = <String, dynamic>{};
  if (pushEnabled != null) body['pushEnabled'] = pushEnabled;
  if (orderUpdates != null) body['orderUpdates'] = orderUpdates;
  if (promotionalOffers != null) body['promotionalOffers'] = promotionalOffers;
  if (paymentAlerts != null) body['paymentAlerts'] = paymentAlerts;
  if (systemNotifications != null) body['systemNotifications'] = systemNotifications;

  final response = await http.put(
    uri,
    headers: getAuthHeaders(token),
    body: json.encode(body),
  );

  if (response.statusCode != 200) {
    throw Exception('Failed to update preferences');
  }
}
```

**Response**:
```json
{
  "success": true,
  "message": "Notification preferences updated",
  "data": {
    "preferences": {
      "pushEnabled": true,
      "orderUpdates": true,
      "promotionalOffers": false,
      "paymentAlerts": true,
      "systemNotifications": true
    }
  }
}
```

---

## Data Models

### Notification Model

```dart
class NotificationModel {
  final String id;
  final String notificationId;
  final NotificationType type;
  final String? postType; // For ADMIN_POST
  final String? systemType; // For SYSTEM_NOTIFICATION
  final String title;
  final String body;
  final String? imageUrl;
  final int likeCount;
  final int commentCount;
  final int viewCount;
  final bool isLiked;
  final bool commentsEnabled;
  final bool likesEnabled;
  final DateTime publishedAt;
  final CreatedBy? createdBy; // For ADMIN_POST
  final NotificationMetadata? metadata; // For SYSTEM_NOTIFICATION
  final ProductShare? sharedProduct; // For PRODUCT_SHARE

  NotificationModel({
    required this.id,
    required this.notificationId,
    required this.type,
    this.postType,
    this.systemType,
    required this.title,
    required this.body,
    this.imageUrl,
    this.likeCount = 0,
    this.commentCount = 0,
    this.viewCount = 0,
    this.isLiked = false,
    this.commentsEnabled = false,
    this.likesEnabled = false,
    required this.publishedAt,
    this.createdBy,
    this.metadata,
    this.sharedProduct,
  });

  factory NotificationModel.fromJson(Map<String, dynamic> json) {
    return NotificationModel(
      id: json['_id'],
      notificationId: json['notificationId'],
      type: json['type'] == 'ADMIN_POST'
          ? NotificationType.adminPost
          : NotificationType.systemNotification,
      postType: json['postType'],
      systemType: json['systemType'],
      title: json['title'],
      body: json['body'],
      imageUrl: json['imageUrl'],
      likeCount: json['likeCount'] ?? 0,
      commentCount: json['commentCount'] ?? 0,
      viewCount: json['viewCount'] ?? 0,
      isLiked: json['isLiked'] ?? false,
      commentsEnabled: json['commentsEnabled'] ?? false,
      likesEnabled: json['likesEnabled'] ?? false,
      publishedAt: DateTime.parse(json['publishedAt']),
      createdBy: json['createdBy'] != null
          ? CreatedBy.fromJson(json['createdBy'])
          : null,
      metadata: json['metadata'] != null
          ? NotificationMetadata.fromJson(json['metadata'])
          : null,
      sharedProduct: json['sharedProduct'] != null
          ? ProductShare.fromJson(json['sharedProduct'])
          : null,
    );
  }
}

enum NotificationType {
  adminPost,
  systemNotification,
}

class CreatedBy {
  final String name;
  final String? profilePicture;

  CreatedBy({required this.name, this.profilePicture});

  factory CreatedBy.fromJson(Map<String, dynamic> json) {
    return CreatedBy(
      name: json['name'],
      profilePicture: json['profilePicture'],
    );
  }
}

class NotificationMetadata {
  final String? orderId;
  final String? paymentId;
  final String? transactionId;
  final double? amount;

  NotificationMetadata({
    this.orderId,
    this.paymentId,
    this.transactionId,
    this.amount,
  });

  factory NotificationMetadata.fromJson(Map<String, dynamic> json) {
    return NotificationMetadata(
      orderId: json['orderId'],
      paymentId: json['paymentId'],
      transactionId: json['transactionId'],
      amount: json['amount']?.toDouble(),
    );
  }
}

class ProductShare {
  final String productId;
  final String productName;
  final String productImage;
  final double productPrice;
  final String productUrl;

  ProductShare({
    required this.productId,
    required this.productName,
    required this.productImage,
    required this.productPrice,
    required this.productUrl,
  });

  factory ProductShare.fromJson(Map<String, dynamic> json) {
    return ProductShare(
      productId: json['productId'],
      productName: json['productName'],
      productImage: json['productImage'],
      productPrice: json['productPrice'].toDouble(),
      productUrl: json['productUrl'],
    );
  }
}
```

### Comment Model

```dart
class CommentModel {
  final String id;
  final String commentId;
  final String text;
  final String userName;
  final String userAvatar;
  final DateTime createdAt;
  final bool isMyComment;

  CommentModel({
    required this.id,
    required this.commentId,
    required this.text,
    required this.userName,
    required this.userAvatar,
    required this.createdAt,
    required this.isMyComment,
  });

  factory CommentModel.fromJson(Map<String, dynamic> json) {
    return CommentModel(
      id: json['_id'],
      commentId: json['commentId'],
      text: json['text'],
      userName: json['userName'],
      userAvatar: json['userAvatar'] ?? '',
      createdAt: DateTime.parse(json['createdAt']),
      isMyComment: json['isMyComment'] ?? false,
    );
  }
}
```

---

## Implementation Guide

### Complete Notification Service

```dart
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

class NotificationService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  final FlutterLocalNotificationsPlugin _localNotifications =
      FlutterLocalNotificationsPlugin();

  static const String baseUrl = 'https://your-api-domain.com';

  // Initialize notifications
  Future<void> initialize() async {
    // Request permissions
    await requestPermission();

    // Initialize local notifications
    await initializeLocalNotifications();

    // Setup message handlers
    setupMessageHandlers();

    // Get and register FCM token
    String? token = await getFCMToken();
    if (token != null) {
      await registerTokenWithBackend(token);
    }

    // Listen for token refresh
    listenToTokenRefresh();
  }

  Future<void> requestPermission() async {
    NotificationSettings settings = await _messaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    );

    print('Permission status: ${settings.authorizationStatus}');
  }

  Future<void> initializeLocalNotifications() async {
    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosSettings = DarwinInitializationSettings();

    const initSettings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
    );

    await _localNotifications.initialize(
      initSettings,
      onDidReceiveNotificationResponse: onNotificationTap,
    );
  }

  void setupMessageHandlers() {
    // Foreground messages
    FirebaseMessaging.onMessage.listen((RemoteMessage message) {
      print('Foreground message: ${message.notification?.title}');
      showLocalNotification(message);
    });

    // Background/Terminated -> Opened
    FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
      print('Notification opened: ${message.data}');
      handleNotificationTap(message.data);
    });

    // Check for initial message (app opened from terminated state)
    checkForInitialMessage();
  }

  Future<void> checkForInitialMessage() async {
    RemoteMessage? initialMessage = await _messaging.getInitialMessage();
    if (initialMessage != null) {
      handleNotificationTap(initialMessage.data);
    }
  }

  void showLocalNotification(RemoteMessage message) async {
    const androidDetails = AndroidNotificationDetails(
      'default',
      'Default Channel',
      channelDescription: 'Default notification channel',
      importance: Importance.high,
      priority: Priority.high,
      showWhen: true,
    );

    const iosDetails = DarwinNotificationDetails();

    const details = NotificationDetails(
      android: androidDetails,
      iOS: iosDetails,
    );

    await _localNotifications.show(
      message.hashCode,
      message.notification?.title,
      message.notification?.body,
      details,
      payload: json.encode(message.data),
    );
  }

  void onNotificationTap(NotificationResponse response) {
    if (response.payload != null) {
      final data = json.decode(response.payload!);
      handleNotificationTap(data);
    }
  }

  void handleNotificationTap(Map<String, dynamic> data) {
    // Navigate to appropriate screen based on notification type
    String? type = data['type'];

    if (type == 'ORDER_CONFIRMATION' || type == 'ORDER_SHIPPED') {
      String? orderId = data['orderId'];
      // Navigate to order details screen
      // navigatorKey.currentState?.pushNamed('/order-details', arguments: orderId);
    } else if (type == 'PAYMENT_SUCCESS') {
      // Navigate to payment/wallet screen
    } else {
      // Navigate to notification details or feed
    }
  }

  Future<String?> getFCMToken() async {
    try {
      return await _messaging.getToken();
    } catch (e) {
      print('Error getting FCM token: $e');
      return null;
    }
  }

  void listenToTokenRefresh() {
    _messaging.onTokenRefresh.listen((newToken) {
      registerTokenWithBackend(newToken);
    });
  }

  Future<void> registerTokenWithBackend(String fcmToken) async {
    try {
      // Get user's auth token from secure storage
      String? authToken = await getAuthToken();
      if (authToken == null) return;

      final uri = Uri.parse('$baseUrl/api/notifications/register-token');

      final response = await http.post(
        uri,
        headers: {
          'Authorization': 'Bearer $authToken',
          'Content-Type': 'application/json',
        },
        body: json.encode({'fcmToken': fcmToken}),
      );

      if (response.statusCode == 200) {
        print('FCM token registered successfully');
      }
    } catch (e) {
      print('Error registering FCM token: $e');
    }
  }

  Future<void> unregisterToken() async {
    try {
      String? authToken = await getAuthToken();
      if (authToken == null) return;

      final uri = Uri.parse('$baseUrl/api/notifications/remove-token');

      await http.post(
        uri,
        headers: {
          'Authorization': 'Bearer $authToken',
        },
      );

      // Delete FCM token
      await _messaging.deleteToken();

      print('FCM token removed');
    } catch (e) {
      print('Error removing FCM token: $e');
    }
  }

  Future<String?> getAuthToken() async {
    // Implement your auth token retrieval logic
    // Example: return await SecureStorage.read('auth_token');
    return null;
  }
}
```

### Notification Feed Screen

```dart
import 'package:flutter/material.dart';

class NotificationFeedScreen extends StatefulWidget {
  @override
  _NotificationFeedScreenState createState() => _NotificationFeedScreenState();
}

class _NotificationFeedScreenState extends State<NotificationFeedScreen> {
  final ScrollController _scrollController = ScrollController();
  List<NotificationModel> notifications = [];
  int currentPage = 1;
  bool isLoading = false;
  bool hasMore = true;

  @override
  void initState() {
    super.initState();
    loadNotifications();
    _scrollController.addListener(_onScroll);
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent * 0.8) {
      if (!isLoading && hasMore) {
        loadMore();
      }
    }
  }

  Future<void> loadNotifications() async {
    setState(() => isLoading = true);

    try {
      final response = await NotificationAPI.getFeed(page: 1);
      setState(() {
        notifications = response['notifications'];
        hasMore = response['pagination']['hasMore'];
        currentPage = 1;
      });
    } catch (e) {
      print('Error loading notifications: $e');
    } finally {
      setState(() => isLoading = false);
    }
  }

  Future<void> loadMore() async {
    if (isLoading || !hasMore) return;

    setState(() => isLoading = true);

    try {
      final response = await NotificationAPI.getFeed(page: currentPage + 1);
      setState(() {
        notifications.addAll(response['notifications']);
        hasMore = response['pagination']['hasMore'];
        currentPage++;
      });
    } catch (e) {
      print('Error loading more: $e');
    } finally {
      setState(() => isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Notifications'),
        actions: [
          // Unread count badge
          FutureBuilder<int>(
            future: NotificationAPI.getUnreadCount(),
            builder: (context, snapshot) {
              if (snapshot.hasData && snapshot.data! > 0) {
                return Badge(
                  label: Text('${snapshot.data}'),
                  child: IconButton(
                    icon: Icon(Icons.notifications),
                    onPressed: () {},
                  ),
                );
              }
              return SizedBox.shrink();
            },
          ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: loadNotifications,
        child: ListView.builder(
          controller: _scrollController,
          itemCount: notifications.length + (hasMore ? 1 : 0),
          itemBuilder: (context, index) {
            if (index >= notifications.length) {
              return Center(child: CircularProgressIndicator());
            }

            return NotificationTile(
              notification: notifications[index],
              onTap: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (_) => NotificationDetailScreen(
                      notification: notifications[index],
                    ),
                  ),
                );
              },
            );
          },
        ),
      ),
    );
  }
}
```

### Notification Tile Widget

```dart
class NotificationTile extends StatelessWidget {
  final NotificationModel notification;
  final VoidCallback onTap;

  const NotificationTile({
    required this.notification,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: EdgeInsets.all(12),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Row(
                children: [
                  if (notification.createdBy != null)
                    CircleAvatar(
                      backgroundImage: NetworkImage(
                        notification.createdBy!.profilePicture ?? '',
                      ),
                      radius: 16,
                    ),
                  SizedBox(width: 8),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          notification.createdBy?.name ?? 'System',
                          style: TextStyle(fontWeight: FontWeight.bold),
                        ),
                        Text(
                          timeAgo(notification.publishedAt),
                          style: TextStyle(fontSize: 12, color: Colors.grey),
                        ),
                      ],
                    ),
                  ),
                  _buildTypeChip(),
                ],
              ),

              SizedBox(height: 8),

              // Title
              Text(
                notification.title,
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),

              SizedBox(height: 4),

              // Body
              Text(
                notification.body,
                maxLines: 3,
                overflow: TextOverflow.ellipsis,
              ),

              // Image
              if (notification.imageUrl != null) ...[
                SizedBox(height: 8),
                ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: Image.network(
                    notification.imageUrl!,
                    height: 200,
                    width: double.infinity,
                    fit: BoxFit.cover,
                  ),
                ),
              ],

              // Engagement
              if (notification.type == NotificationType.adminPost) ...[
                SizedBox(height: 8),
                Row(
                  children: [
                    if (notification.likesEnabled)
                      _buildStat(Icons.favorite, notification.likeCount),
                    SizedBox(width: 16),
                    if (notification.commentsEnabled)
                      _buildStat(Icons.comment, notification.commentCount),
                    SizedBox(width: 16),
                    _buildStat(Icons.visibility, notification.viewCount),
                  ],
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTypeChip() {
    Color color;
    String label;

    if (notification.type == NotificationType.adminPost) {
      switch (notification.postType) {
        case 'OFFER':
          color = Colors.orange;
          label = 'Offer';
          break;
        case 'PRODUCT_SHARE':
          color = Colors.blue;
          label = 'Product';
          break;
        default:
          color = Colors.purple;
          label = 'Post';
      }
    } else {
      color = Colors.green;
      label = 'Update';
    }

    return Chip(
      label: Text(label, style: TextStyle(fontSize: 10)),
      backgroundColor: color.withOpacity(0.2),
      labelStyle: TextStyle(color: color),
      visualDensity: VisualDensity.compact,
    );
  }

  Widget _buildStat(IconData icon, int count) {
    return Row(
      children: [
        Icon(icon, size: 16, color: Colors.grey),
        SizedBox(width: 4),
        Text('$count', style: TextStyle(fontSize: 12)),
      ],
    );
  }

  String timeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inDays > 0) {
      return '${difference.inDays}d ago';
    } else if (difference.inHours > 0) {
      return '${difference.inHours}h ago';
    } else if (difference.inMinutes > 0) {
      return '${difference.inMinutes}m ago';
    } else {
      return 'Just now';
    }
  }
}
```

---

## UI/UX Guidelines

### 1. Notification Feed

**Design Specs**:
- Card-based layout with elevation
- 12px horizontal margin, 6px vertical margin
- Admin avatar/icon on left (40px circle)
- Type badge on top right (Offer/Post/Update)
- Title: 16px bold
- Body: 14px regular, 3-line max with ellipsis
- Image: 16:9 aspect ratio, rounded corners (8px)
- Engagement icons: 16px, grey color

**Colors**:
- Offer: Orange (#FF9800)
- Post: Purple (#9C27B0)
- Product: Blue (#2196F3)
- System Update: Green (#4CAF50)

### 2. Notification Detail

**Layout**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [Back] Title                    [...] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [Avatar] Admin Name     [Type Badge] â”‚
â”‚          Published time ago          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                      â”‚
â”‚ Full Title Here                      â”‚
â”‚                                      â”‚
â”‚ Full body text with all details      â”‚
â”‚ and formatting preserved...          â”‚
â”‚                                      â”‚
â”‚ [â”€â”€â”€â”€â”€â”€ Image â”€â”€â”€â”€â”€â”€]                â”‚
â”‚                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ðŸ‘ 125 likes  ðŸ’¬ 45 comments         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [â¤ï¸ Like] [ðŸ’¬ Comment] [ðŸ“¤ Share]    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Comments (45)                        â”‚
â”‚                                      â”‚
â”‚ [Avatar] John Doe â€¢ 2h ago          â”‚
â”‚ Great offer! Thanks                 â”‚
â”‚                               [Delete]â”‚
â”‚                                      â”‚
â”‚ [Avatar] Jane Smith â€¢ 1h ago        â”‚
â”‚ When does this expire?              â”‚
â”‚                                      â”‚
â”‚ [Load more comments...]             â”‚
â”‚                                      â”‚
â”‚ [Add comment input...]       [Send] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Animations

- Smooth fade-in when loading notifications
- Ripple effect on tap
- Heart animation when liking
- Slide-in animation for new comments

### 4. Empty States

**No Notifications**:
```dart
Center(
  child: Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: [
      Icon(Icons.notifications_none, size: 80, color: Colors.grey),
      SizedBox(height: 16),
      Text('No notifications yet'),
      Text('We\'ll notify you when something arrives'),
    ],
  ),
)
```

### 5. Error States

Show user-friendly error messages:
- Network error: "Can't load notifications. Check your connection."
- Server error: "Something went wrong. Please try again."
- Rate limit: "Too many requests. Please wait a moment."

---

## Testing

### Manual Testing Checklist

**Notification Feed**:
- [ ] Feed loads on app start
- [ ] Pull-to-refresh works
- [ ] Infinite scroll loads more notifications
- [ ] Empty state shows when no notifications
- [ ] Loading indicator shows while fetching

**Notification Detail**:
- [ ] Full content displays correctly
- [ ] Image loads and displays properly
- [ ] Like button toggles correctly
- [ ] Like count updates in real-time
- [ ] Comments load with pagination
- [ ] Add comment works
- [ ] Delete own comment works
- [ ] Cannot delete others' comments

**Push Notifications**:
- [ ] Foreground: Shows local notification
- [ ] Background: Notification appears in system tray
- [ ] Terminated: Notification appears and opens app
- [ ] Tap notification opens correct screen
- [ ] Deep linking works for different notification types

**Preferences**:
- [ ] Can toggle push notifications on/off
- [ ] Individual preference toggles work
- [ ] Changes save correctly
- [ ] FCM token registers on login
- [ ] FCM token removes on logout

### Test Cases

**Test 1: Receive Push Notification**
1. Login to app
2. Keep app in background
3. Admin sends notification from panel
4. Verify notification appears in system tray
5. Tap notification
6. Verify app opens to notification detail

**Test 2: Like and Comment**
1. Open notification feed
2. Tap on an admin post
3. Tap like button
4. Verify like count increases
5. Add a comment
6. Verify comment appears
7. Delete comment
8. Verify comment is removed

**Test 3: Pagination**
1. Open notification feed
2. Scroll to bottom
3. Verify loading indicator appears
4. Verify more notifications load
5. Continue scrolling until no more

---

## Troubleshooting

### Push Notifications Not Received

**Check**:
1. FCM token registered with backend
2. Firebase Cloud Messaging enabled in Firebase Console
3. Notification permissions granted on device
4. User preferences allow push notifications
5. Device has internet connection

**Debug**:
```dart
// Check FCM token
String? token = await FirebaseMessaging.instance.getToken();
print('FCM Token: $token');

// Check if registered with backend
// Make API call to check user's FCM token in database
```

### Images Not Loading

**Check**:
1. S3 bucket CORS configuration
2. Image URL is valid and accessible
3. Network permissions in Android manifest
4. Use cached network image package for better performance

**Solution**:
```dart
CachedNetworkImage(
  imageUrl: notification.imageUrl!,
  placeholder: (context, url) => CircularProgressIndicator(),
  errorWidget: (context, url, error) => Icon(Icons.error),
)
```

### API Authentication Failed

**Check**:
1. JWT token is valid and not expired
2. Token included in Authorization header
3. Backend verifies Firebase tokens correctly

**Debug**:
```dart
print('Auth Header: Bearer $token');
print('Response Status: ${response.statusCode}');
print('Response Body: ${response.body}');
```

### Comments Not Showing

**Check**:
1. Notification has `commentsEnabled: true`
2. Pagination parameters correct
3. Comments API endpoint returning data

---

## Additional Resources

### Packages to Install

```yaml
dependencies:
  # Core
  http: ^1.1.0

  # Firebase
  firebase_core: ^2.24.2
  firebase_messaging: ^14.7.9

  # Notifications
  flutter_local_notifications: ^16.3.0

  # UI
  cached_network_image: ^3.3.0
  timeago: ^3.6.0

  # State Management (choose one)
  provider: ^6.1.1
  riverpod: ^2.4.9
  bloc: ^8.1.2

  # Storage
  shared_preferences: ^2.2.2
  flutter_secure_storage: ^9.0.0
```

### Useful Links

- [Firebase Messaging Documentation](https://firebase.flutter.dev/docs/messaging/overview)
- [Flutter Local Notifications](https://pub.dev/packages/flutter_local_notifications)
- [API Base URL](#): Replace with your actual API URL

---

## Summary

### Quick Integration Steps

1. **Setup Firebase**
   - Add Firebase to Flutter project
   - Configure Android & iOS
   - Initialize in main.dart

2. **Request Permissions**
   - Request notification permissions on app start
   - Handle permission denial gracefully

3. **Register FCM Token**
   - Get FCM token
   - Send to backend via `/register-token` endpoint
   - Listen for token refresh

4. **Implement Notification Feed**
   - Fetch notifications with pagination
   - Display in list with appropriate UI
   - Handle pull-to-refresh and infinite scroll

5. **Handle Push Notifications**
   - Setup message handlers for foreground, background, terminated
   - Show local notifications when app is in foreground
   - Implement deep linking to navigate to correct screens

6. **Implement Detail Screen**
   - Show full notification content
   - Add like/comment functionality
   - Handle image display

7. **Add Preferences Screen**
   - Let users control notification types
   - Update backend preferences
   - Register/unregister FCM token based on settings

**API Version**: v1
**Last Updated**: November 2025
**Contact**: Backend Development Team
